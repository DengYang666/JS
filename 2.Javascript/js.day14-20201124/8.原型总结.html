<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>原型总结</title>
</head>
<body>
    <script>
        /*
            总结:
                原型: 
                    构造函数的方式创建对象.
                    对象的方法存在 构造函数里面,比较浪费空间.
                    构造函数有一个prototype 原型对象. 它的属性或方法可以被 构造函数的对象的共享.
                    对象没有prototype这种属性 而是 __proto__    p1.__proto__ === People.prototype
                    规范叫法:  prototype 原型对象
                              __proto__ 对象原型  它是对象的原型.
                    prototype 可以扩展构造函数.

                    2.constructor
                        __proto__ 对象原型里面有一个默认的constructor.
                        这个constructor 指向了构造函数本身.
                       问题: 如果用一个对象覆盖了 prototype 属性,constructor就消失了.
                            注意: 一定要在覆盖对象里面 重写 constructor 执行构造函数.
                    为什么要这么做:如果要通过对象来修改构造函数
                        用这种方式:  对象.constructor.prototype
                    
                    归纳:  构造函数的函数的修改 或 扩展用 prototype
                           通过对象来修改构造函数 constructor
            继承:
        */
        function People(){
            this.name='Trump';
            // this.sayHi=function(){//每一个构造函数创建的对象都有一个该函数. 浪费空间
            // }
        }
        People.prototype.sayHi=function(){//sayHi方法被附加在prototype 原型对象上面 可以被People的对象共享
        }
        People.prototype={
            constructor:People
        };
        var p1=new People();
            p1.sayHi();
        var p2=new People();
        p2.sayHi();
        console.log(p1);
    </script>
</body>
</html>